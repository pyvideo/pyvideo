{
    "added": "2012-08-31T16:35:01",
    "category": "SciPy 2012",
    "copyright_text": "CC BY-SA",
    "description": "Recent years have provided a wealth of projects showing that using Python for\nscientific applications outperforms even popular choices such as Matlab. A\nmajor factor driving these successes is the efficient utilization of multi-\ncores, GPUs for general-purpose computation and scaling computations to\nclusters.\n\nHowever, often these advances sacrifice some of the high-productivity features\nof Python by introducing new language constructs, enforcing new language\nsemantics and/or enforcing explicit data types. The result is that the user\nwill have to rewrite existing Python applications to use the Python extension.\n\nIn order to use GPGPUs in Python, a popular approach is to embed CUDA/OpenCL\ncode kernels directly in the Python application. The programming productivity\nof this approach is better and more readable than C/C++ applications but it is\nstill inferior to native Python code. Furthermore, the approach enforces\nhardware specific programming and thus requires intimate knowledge of the\nunderlying hardware and the CUDA/OpenCL programming model.\n\nCopenhagen Vector Byte Code (cphVB) strives to provide a high-performance\nback-end for Numerical Python (NumPy) without reducing the high-productivity\nof Python/NumPy. Without any involvement of the user, cphVB will transform\nregular sequential Python/NumPy applications into high-performance\napplications. The cphVB runtime system is capable of utilizing a broad range\nof computing platforms efficiently, e.g. Multi-core CPUs, GPGPUs and clusters\nof such machines.\n\ncphVB consists of a bridge that translates NumPy array operations into cphVB\nvector operations. The bridge will send these vector operations to a Vector\nEngine that performs the actual execution of the operations. cphVB comes with\na broad range of Vector Engines optimized to specific hardware architectures,\nsuch as multi-core CPUs, GPGPU and clusters of said architectures. Thus, cphVB\nprovides a high-productivity, high-performance framework that support legacy\nNumPy applications without changing a single line of code.\n\n",
    "duration": null,
    "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/HFxn3mSp9ww?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/HFxn3mSp9ww?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>",
    "id": 1209,
    "language": "English",
    "quality_notes": "",
    "recorded": "2012-07-18",
    "related_urls": [],
    "slug": "bringing-high-performance-to-pythonnumpy-without",
    "source_url": "https://www.youtube.com/watch?v=HFxn3mSp9ww",
    "speakers": [
        "Brian Vinter",
        "Mads Ruben Burgdorff Kristensen",
        "Simon Andreas Frimann Lund",
        "Troels Blum"
    ],
    "state": 1,
    "summary": "",
    "tags": [
        "hpc"
    ],
    "thumbnail_url": "http://i1.ytimg.com/vi/HFxn3mSp9ww/hqdefault.jpg",
    "title": "Bringing High Performance to Python/Numpy Without Changing a Single Line of Code.",
    "updated": "2014-04-08T20:28:27.138",
    "video_flv_download_only": false,
    "video_flv_length": null,
    "video_flv_url": "",
    "video_mp4_download_only": false,
    "video_mp4_length": null,
    "video_mp4_url": "http://s3.us.archive.org/nextdayvideo/enthought/scipy_2012/Bringing_High_Performance_to_P.mp4?Signature=w983Dyy%2Fzuho%2FUZhUhfx1A0vcAY%3D&Expires=1346444523&AWSAccessKeyId=FEWGReWX3QbNk0h3",
    "video_ogv_download_only": false,
    "video_ogv_length": null,
    "video_ogv_url": null,
    "video_webm_download_only": false,
    "video_webm_length": null,
    "video_webm_url": "",
    "whiteboard": ""
}